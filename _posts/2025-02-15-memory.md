---
# layout: post
title: Android 内存优化那些事
date: 2025-02-15 24:58 +0800
last_modified_at: 2025-02-15 24:58 +0800
tags: [性能, 内存]
toc: true
---
# Android 内存优化那些事
## 为什么要进行内存优化
1. **提高应用程序的流畅性**，内存的不合理使用会导致频繁的GC（垃圾回收），发生GC时，需要暂停正在执行的程序。另外给应用程序分配内存也有一定耗时这些都回导致程序的不流畅。
2. **避免OOM**， Android 系统为每个应用分配的内存是有限的（通常为几十MB到几百MB）。如果应用内存使用超出限制，会触发 `OutOfMemoryError`（OOM），导致应用崩溃。
3. **避免程序被杀死**，Android 系统会根据内存使用情况杀死占用内存过多的应用（Low Memory Killer，LMK）。优化内存使用可以降低应用被系统杀死的概率。
## 垃圾回收（Garbage Collection, GC）
提到Android内存优化不得不提Android的垃圾回收机制。垃圾回收是一种自动内存管理机制，用于识别和回收程序中不再使用的对象，释放它们占用的内存。在 Java 和 Kotlin 中，开发者不需要手动释放对象占用的内存。垃圾回收机制会自动处理内存释放，避免内存泄漏和内存溢出。
### 垃圾回收的原理
1. **标记阶段**。当对象不再被引用时，它就变成了“垃圾”，垃圾回收器会将其回收。Android系统采用可达性分析方法标识垃圾对象，即垃圾回收器从根对象（如静态变量、活动线程、局部变量等）开始，遍历所有可达对象，没有被遍历的对象即为垃圾对象。
2. **清除阶段**。Android中堆内存分为新生代和老年代（不同于普通JVM虚拟机，ART虚拟机没有老年代）。不同分代采用不同的清除方法，新生代使用复制算法。老年代使用并发标记清除（Concurrent Mark-Sweep (CMS)）。
### 垃圾回收不当引起的问题
1. **内存泄漏**。对象不再使用但仍被引用，导致无法被回收，即为内存泄漏。
2. **内存溢出**。内存不足时触发，通常由内存泄漏或大对象分配引起。
3. **内存抖动**。频繁创建和销毁对象，导致频繁的垃圾回收。
## 图片管理
图片是Andorid应用中常见的内存消耗大户。图片内存占用 = 图片宽度 × 图片高度 × 每个像素占用的字节数。例如，一张 1920x1080 的 ARGB-8888 格式图片占用的内存为：1920 * 1080 * 4 bytes = 8,294,400 bytes ≈ 7.91 MB，常见的图片内存管理手段有如下几种。

1. **使用合适的像素格式** 。常用的像素格式有`ARGB_8888`：每个像素占用 4 字节（默认格式），`RGB_565`：每个像素占用 2 字节（适合不透明图片）。使用`RGB_565`格式可以比使用`ARGB_8888`格式节省一半内存。
2. **使用`inSampleSize`**。使用`inSampleSize`可以将图片按比例缩放，例如`inSampleSize=2` 会将图片宽高缩小为原来的 1/2，内存占用减少为 1/4。
3. **使用BitmapRegionDecoder按需加载图片区域**。如果一个图片我们只需要渲染其中一部分的话，就没必要将全部区域加载到内存中。
4. **回收释放图片**。在图片不再被需要的时候，放入缓存池中或者使用`recycle`方法回收图片并且置为空。
5. **使用`inBitmap`复用Bitmap**。使用 `inBitmap` 复用已分配的 Bitmap 内存。
6. **使用合适的图片格式**。矢量图（VectorDrawable）的内存占用小于JPG小于位图

## 内存优化的方法
1. **在合适的时候释放内存避免内存泄漏**。
2. **使用缓存池，或者局部变量改成员变量等方法避免反复创建销毁对象**。
3. **做好图片管理，避免因图片不当使用导致的内存问题**。
4. **使用`@IntDef`,`@StringDef`代替枚举**。枚举再程序运行是其内存大小大概是一个int类型常量的5倍。在可读性要求，类安全性要求低，内存要求高的场景下使用避免使用枚举。
5. **使用合适的数据结构**。例如使用SparseArray内存大小要小于HashMap。
6. **及时释放资源**。对于一些资源类，如文件流、数据库连接、传感器监听等，在使用完毕后一定要及时释放资源。否则，这些资源所占用的内存无法被回收，会导致内存泄漏。
7. **注意第三方库**。在引用第三方库的时候要注意：
   1. 第三方库有没有内存泄漏等内存问题。
   2. 第三方库是否需要主动释放内存。
8. **释放native内存**。不同于Java或Kotlin代码，native代码中分配的内存，需要开发者主动释放。

## 内存监控方法
* **Android Profiler**：这是 Android Studio 提供的一款强大的性能分析工具，它可以实时监控应用的 CPU、内存、网络等方面的性能数据。通过 Android Profiler，开发者可以直观地看到应用的内存分配情况、对象的创建和销毁过程，以及垃圾回收的时机等，从而快速定位内存问题。
* **MAT（Memory Analyzer Tool）**：这是一款专门用于分析 Java 堆内存的工具。它可以分析内存转储文件（hprof 文件），帮助开发者找出内存泄漏的原因和位置。MAT 提供了丰富的分析功能，如对象引用树分析、支配树分析等，能够帮助开发者深入了解内存的使用情况。
* * **Logcat**： 查看垃圾回收的日志信息（如 `GC_FOR_ALLOC`、`GC_CONCURRENT` 等）。
* **Debug API**： 使用 `Debug.getMemoryInfo()` 获取内存信息。
* **LeakCanary**：检测内存泄漏，帮助定位问题。


